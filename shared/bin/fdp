#!/usr/bin/env bash
#
# fdp: Find Projects - Discovers project directories based on configurable markers
#
# Usage:
#   fdp                    # List all projects
#   fdp | fzf              # Fuzzy find projects
#   cd $(fdp | fzf)        # cd to selected project
#
# Config: ~/.config/fdp/config.conf

set -euo pipefail

CONFIG_FILE="${XDG_CONFIG_HOME:-$HOME/.config}/fdp/config.conf"

# Cache configuration
CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/fdp"
CACHE_TTL=300  # 5 minutes default
USE_CACHE=true
VERBOSE=false
DEBUG_START_TIME=""

# Icon configuration
USE_ICONS=false
STRIP_ICONS=false  # Strip icons from output even when enabled
DEFAULT_ICON=""  # Fallback icon
declare -A CONFIG_ICON_MAP=()  # Icons from config file
declare -A CLI_ICON_MAP=()     # Icons from CLI flags
declare -A ICON_MAP=()         # Final merged icon map

# Marker specificity ordering (for multiple marker resolution)
# Higher index = more specific (language-specific > generic)
declare -A MARKER_SPECIFICITY=(
  # Generic markers (low priority)
  [".git"]=1
  ["Makefile"]=1

  # Language-specific markers (high priority)
  ["package.json"]=10
  ["Cargo.toml"]=10
  ["go.mod"]=10
  ["pyproject.toml"]=10
  ["composer.json"]=10
  ["Gemfile"]=10
  ["mix.exs"]=10
  ["pom.xml"]=10
  ["build.gradle"]=10
)

# Default icon mappings for standard markers
# Users can override via config file or --icon-map CLI flag
declare -A DEFAULT_MARKER_ICONS=(
  [".git"]=""               # Git
  ["package.json"]="󰎙"       # Node.js/npm
  ["Cargo.toml"]=""        # Rust
  ["go.mod"]="󰟓"            # Go
  ["pyproject.toml"]=""    # Python
  ["composer.json"]=""     # PHP/Composer
  ["Gemfile"]=""           # Ruby
  ["mix.exs"]=""           # Elixir
  ["pom.xml"]=""           # Maven/Java
  ["build.gradle"]=""      # Gradle/Java
  ["Makefile"]=""          # Make/Build
)

# Show help message
show_help() {
  cat <<EOF
fdp: Find Projects - Discovers project directories based on configurable markers

Usage:
  fdp [OPTIONS]
  fdp | fzf              # Fuzzy find projects
  cd \$(fdp | fzf)        # cd to selected project

Options:
  -c, --config FILE      Use custom config file (default: ~/.config/fdp/config.conf)
  -p, --path PATH        Add search path (can be repeated, merges with config)
  -m, --marker MARKER    Add project marker (can be repeated, merges with config)
  -e, --exclude PATTERN  Exclude pattern for fd (can be repeated, merges with config)
  -d, --max-depth NUM    Override maximum search depth (overrides config)
  --icons                Enable marker-based icons (uses config + defaults)
  --icon-map MARKER:ICON Add/override icon mapping (e.g., '.git:')
  --strip                Strip icons from output (use with --icons for clean paths)
  --no-cache             Skip cache, force fresh search
  --clear-cache          Clear all fdp cache files and exit
  -v, --verbose          Enable debug output (shows timing and cache info)
  -h, --help             Show this help message

Examples:
  fdp                                    # Use config/defaults
  fdp --config ~/my-projects.conf        # Use custom config file
  fdp --max-depth 1                      # Shallow search
  fdp --path ~/experimental              # Add temporary search path
  fdp --marker "Dockerfile"              # Add custom marker
  fdp --exclude ".terraform" -e "vendor" # Exclude patterns
  fdp -p ~/temp -m "go.work" -d 2        # Combine multiple flags
  fdp --no-cache                         # Skip cache and search fresh
  fdp --clear-cache                      # Clear all cached results
  fdp --icons                            # Show icons in output
  fdp --icons | fzf                      # Icons visible in fzf picker
  fdp --icons --strip | fzf              # Icons hidden, clean paths for cd
  cd \$(fdp --icons --strip | fzf)       # Use with cd command
  fdp --icon-map ".git:" --icons        # Override .git icon

Config file: ${CONFIG_FILE}
Icon syntax (in config): icon MARKER = ICON_CHARACTER
Example: icon package.json =
See: https://github.com/sharkdp/fd for exclude pattern syntax
EOF
}

# Default configuration
DEFAULT_SEARCH_PATHS=(
  "$HOME/projects"
  "$HOME/code"
  "$HOME/src"
)

DEFAULT_MARKERS=(
  ".git"
  "package.json"
  "Cargo.toml"
  "go.mod"
  "pyproject.toml"
  "composer.json"
  "Gemfile"
  "mix.exs"
  "pom.xml"
  "build.gradle"
  "Makefile"
)

DEFAULT_MAX_DEPTH=3
DEFAULT_EXCLUDES=()

# Arrays to hold config values
CONFIG_SEARCH_PATHS=()
CONFIG_MARKERS=()
CONFIG_MAX_DEPTH=""
CONFIG_EXCLUDES=()

# Arrays to hold CLI flag values
CLI_SEARCH_PATHS=()
CLI_MARKERS=()
CLI_MAX_DEPTH=""
CLI_EXCLUDES=()

# Parse command-line arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help)
      show_help
      exit 0
      ;;
    --clear-cache)
      rm -rf "${CACHE_DIR}" 2>/dev/null || true
      echo "Cache cleared: ${CACHE_DIR}" >&2
      exit 0
      ;;
    --no-cache)
      USE_CACHE=false
      shift
      ;;
    -v|--verbose)
      VERBOSE=true
      shift
      ;;
    -c|--config)
      if [[ -z "${2:-}" ]]; then
        echo "Error: --config requires a value" >&2
        exit 1
      fi
      # Expand tilde
      CONFIG_FILE="${2/#\~/$HOME}"
      shift 2
      ;;
    -p|--path)
      if [[ -z "${2:-}" ]]; then
        echo "Error: --path requires a value" >&2
        exit 1
      fi
      # Expand tilde and environment variables
      path="${2/#\~/$HOME}"
      path=$(eval echo "${path}")
      CLI_SEARCH_PATHS+=("${path}")
      shift 2
      ;;
    -m|--marker)
      if [[ -z "${2:-}" ]]; then
        echo "Error: --marker requires a value" >&2
        exit 1
      fi
      CLI_MARKERS+=("$2")
      shift 2
      ;;
    -e|--exclude)
      if [[ -z "${2:-}" ]]; then
        echo "Error: --exclude requires a value" >&2
        exit 1
      fi
      CLI_EXCLUDES+=("$2")
      shift 2
      ;;
    -d|--max-depth)
      if [[ -z "${2:-}" ]]; then
        echo "Error: --max-depth requires a value" >&2
        exit 1
      fi
      if ! [[ "$2" =~ ^[0-9]+$ ]]; then
        echo "Error: --max-depth must be a number" >&2
        exit 1
      fi
      CLI_MAX_DEPTH="$2"
      shift 2
      ;;
    --icons)
      USE_ICONS=true
      shift
      ;;
    --strip)
      STRIP_ICONS=true
      shift
      ;;
    --icon-map)
      if [[ -z "${2:-}" ]]; then
        echo "Error: --icon-map requires MARKER:ICON value" >&2
        exit 1
      fi
      if [[ ! "$2" =~ ^([^:]+):(.*)$ ]]; then
        echo "Error: --icon-map format must be MARKER:ICON (e.g., '.git:')" >&2
        exit 1
      fi
      marker="${BASH_REMATCH[1]}"
      icon="${BASH_REMATCH[2]}"
      CLI_ICON_MAP["${marker}"]="${icon}"
      shift 2
      ;;
    *)
      echo "Error: Unknown option: $1" >&2
      echo "Run 'fdp --help' for usage information" >&2
      exit 1
      ;;
  esac
done

# Read config file if it exists
if [[ -f "${CONFIG_FILE}" ]]; then
  while IFS= read -r line || [[ -n "${line}" ]]; do
    # Skip empty lines and comments
    [[ -z "${line}" || "${line}" =~ ^[[:space:]]*# ]] && continue

    # Parse search_path entries
    if [[ "${line}" =~ ^search_path[[:space:]]*=[[:space:]]*(.+)$ ]]; then
      path="${BASH_REMATCH[1]}"
      # Expand tilde
      path="${path/#\~/$HOME}"
      CONFIG_SEARCH_PATHS+=("${path}")
    # Parse marker entries
    elif [[ "${line}" =~ ^marker[[:space:]]*=[[:space:]]*([^#[:space:]]+) ]]; then
      CONFIG_MARKERS+=("${BASH_REMATCH[1]}")
    # Parse exclude entries
    elif [[ "${line}" =~ ^exclude[[:space:]]*=[[:space:]]*(.+)$ ]]; then
      CONFIG_EXCLUDES+=("${BASH_REMATCH[1]}")
    # Parse max_depth
    elif [[ "${line}" =~ ^max_depth[[:space:]]*=[[:space:]]*([0-9]+) ]]; then
      CONFIG_MAX_DEPTH="${BASH_REMATCH[1]}"
    # Parse icon mappings
    elif [[ "${line}" =~ ^icon[[:space:]]+([^=]+)[[:space:]]*=[[:space:]]*(.*)$ ]]; then
      marker="${BASH_REMATCH[1]}"
      icon="${BASH_REMATCH[2]}"
      CONFIG_ICON_MAP["${marker}"]="${icon}"
    fi
  done < "${CONFIG_FILE}"
fi

# Merge configuration: CLI flags + Config + Defaults
# Multi-value options (search_path, marker, exclude): Additive merge
# Single-value options (max_depth): CLI > Config > Default

# Merge search paths: config + CLI (or defaults if both empty)
SEARCH_PATHS=("${CONFIG_SEARCH_PATHS[@]}" "${CLI_SEARCH_PATHS[@]}")
[[ ${#SEARCH_PATHS[@]} -eq 0 ]] && SEARCH_PATHS=("${DEFAULT_SEARCH_PATHS[@]}")

# Merge markers: config + CLI (or defaults if both empty)
MARKERS=("${CONFIG_MARKERS[@]}" "${CLI_MARKERS[@]}")
[[ ${#MARKERS[@]} -eq 0 ]] && MARKERS=("${DEFAULT_MARKERS[@]}")

# Merge excludes: config + CLI (or defaults if both empty)
EXCLUDES=("${CONFIG_EXCLUDES[@]}" "${CLI_EXCLUDES[@]}")
[[ ${#EXCLUDES[@]} -eq 0 ]] && EXCLUDES=("${DEFAULT_EXCLUDES[@]}")

# Max depth: CLI overrides config, fallback to default
MAX_DEPTH="${CLI_MAX_DEPTH:-${CONFIG_MAX_DEPTH:-$DEFAULT_MAX_DEPTH}}"

# Merge icon maps: Defaults < Config < CLI
# Start with defaults for standard markers
ICON_MAP=()
for marker in "${!DEFAULT_MARKER_ICONS[@]}"; do
  ICON_MAP["${marker}"]="${DEFAULT_MARKER_ICONS[$marker]}"
done
# Config overrides defaults
for marker in "${!CONFIG_ICON_MAP[@]}"; do
  ICON_MAP["${marker}"]="${CONFIG_ICON_MAP[$marker]}"
done
# CLI overrides everything
for marker in "${!CLI_ICON_MAP[@]}"; do
  ICON_MAP["${marker}"]="${CLI_ICON_MAP[$marker]}"
done

# Filter search paths that actually exist
EXISTING_PATHS=()
for path in "${SEARCH_PATHS[@]}"; do
  [[ -d "${path}" ]] && EXISTING_PATHS+=("${path}")
done

# Exit if no valid search paths
if [[ ${#EXISTING_PATHS[@]} -eq 0 ]]; then
  echo "Error: No valid search paths found" >&2
  exit 1
fi

# Check if fd is available
if ! command -v fd &> /dev/null; then
  echo "Error: 'fd' command not found. Please install fd-find." >&2
  echo "  macOS: brew install fd" >&2
  echo "  Ubuntu: apt install fd-find" >&2
  exit 1
fi

# Build fd regex pattern from markers
# Escape special regex characters and join with |
build_pattern() {
  local pattern=""
  for marker in "${MARKERS[@]}"; do
    # Escape dots and other regex special chars
    local escaped="${marker//./\\.}"
    escaped="${escaped//\$/\\$}"

    # Add anchors for exact match
    if [[ "${marker}" == .* ]]; then
      # Hidden files/dirs like .git
      pattern="${pattern}^${escaped}\$|"
    else
      # Regular files like package.json
      pattern="${pattern}^${escaped}\$|"
    fi
  done
  # Remove trailing |
  echo "${pattern%|}"
}

PATTERN=$(build_pattern)

# Build exclude arguments for fd
EXCLUDE_ARGS=()
for exclude in "${EXCLUDES[@]}"; do
  EXCLUDE_ARGS+=(--exclude "${exclude}")
done

# Debug output
if [[ "${VERBOSE}" == "true" ]]; then
  echo "DEBUG: PATTERN: ${PATTERN}" >&2
  echo "DEBUG: MAX_DEPTH: ${MAX_DEPTH}" >&2
  echo "DEBUG: PATHS: ${EXISTING_PATHS[@]}" >&2
  echo "DEBUG: EXCLUDES: ${EXCLUDES[@]}" >&2
  echo "DEBUG: CACHE_DIR: ${CACHE_DIR}" >&2
  DEBUG_START_TIME=$(date +%s%3N)
fi

# Generate cache file key based on search parameters
# Use hash of all config to detect changes
get_cache_file() {
  local cache_key
  local icon_hash=""

  # Include icon map in cache key if icons enabled
  if [[ "${USE_ICONS}" == "true" ]]; then
    icon_hash=$(printf '%s=%s\n' "${!ICON_MAP[@]}" "${ICON_MAP[@]}" | sort | md5sum | cut -d' ' -f1)
  fi

  cache_key=$(echo "${SEARCH_PATHS[@]}:${MARKERS[@]}:${EXCLUDES[@]}:${MAX_DEPTH}:${USE_ICONS}:${icon_hash}" | md5sum | cut -d' ' -f1)
  echo "${CACHE_DIR}/cache-${cache_key}.txt"
}

CACHE_FILE=$(get_cache_file)

# Check cache validity and return early if valid
check_and_use_cache() {
  if [[ "${USE_CACHE}" != "true" || ! -f "${CACHE_FILE}" ]]; then
    return 1
  fi

  # Check cache age
  if command -v stat &> /dev/null; then
    # Try macOS stat format first, fall back to Linux
    local cache_age
    if stat -f %m "${CACHE_FILE}" &>/dev/null; then
      cache_age=$(($(date +%s) - $(stat -f %m "${CACHE_FILE}")))
    else
      cache_age=$(($(date +%s) - $(stat -c %Y "${CACHE_FILE}")))
    fi

    if [[ ${cache_age} -lt ${CACHE_TTL} ]]; then
      cat "${CACHE_FILE}"
      if [[ "${VERBOSE}" == "true" ]]; then
        echo "DEBUG: Cache hit (age: ${cache_age}s)" >&2
      fi
      return 0
    fi
  fi

  return 1
}

# Try to use cache
if check_and_use_cache; then
  if [[ "${VERBOSE}" == "true" ]]; then
    echo "DEBUG: Using cached results" >&2
  fi
  exit 0
fi

if [[ "${VERBOSE}" == "true" ]]; then
  echo "DEBUG: Cache miss or disabled, searching..." >&2
fi

# Function to get icon for a directory (checks which markers it contains)
get_icon_for_dir() {
  local dir="$1"
  local best_marker=""
  local best_specificity=0

  # Check which markers exist in this directory
  for marker in "${MARKERS[@]}"; do
    if [[ -e "${dir}/${marker}" ]]; then
      local specificity="${MARKER_SPECIFICITY[$marker]:-5}"  # Default mid-level
      if [[ $specificity -gt $best_specificity ]]; then
        best_specificity=$specificity
        best_marker="$marker"
      fi
    fi
  done

  # Return icon for best marker, or default
  echo "${ICON_MAP[$best_marker]:-$DEFAULT_ICON}"
}

# Optimized search using --exec-batch for efficient directory extraction
# Original: --exec dirname {} \;  (spawns one dirname per file)
# Optimized: --exec-batch dirname (batches multiple paths per dirname call)
# This reduces process spawning from ~1500 to ~15-50 calls for large codebases

# Use the same efficient search for both icon and non-icon modes
# Icons are applied only to the output, not the search strategy
results=$(
  fd --hidden \
     --no-ignore-vcs \
     --max-depth "${MAX_DEPTH}" \
     --regex "${PATTERN}" \
     "${EXCLUDE_ARGS[@]}" \
     "${EXISTING_PATHS[@]}" \
     --exec-batch dirname \
  | sort -u
)

# Apply icons to results if enabled
if [[ "${USE_ICONS}" == "true" ]]; then
  results=$(while IFS= read -r dir; do
    if [[ -n "${dir}" ]]; then
      icon=$(get_icon_for_dir "${dir}")
      echo "${icon} ${dir}"
    fi
  done <<< "${results}")
fi

# Strip icons if requested
if [[ "${USE_ICONS}" == "true" ]] && [[ "${STRIP_ICONS}" == "true" ]]; then
  results=$(echo "$results" | sed 's/^[^ ]* //')
fi

# Write results to cache and output
mkdir -p "${CACHE_DIR}"
echo "${results}" | tee "${CACHE_FILE}"

if [[ "${VERBOSE}" == "true" ]]; then
  debug_end_time=$(date +%s)
  elapsed=$((debug_end_time - $(echo "${DEBUG_START_TIME}" | sed 's/[^0-9]*//g' | cut -c1-10)))
  line_count=$(echo "${results}" | wc -l)
  echo "DEBUG: Search completed in ${elapsed}s" >&2
  echo "DEBUG: Found ${line_count} projects" >&2
fi
