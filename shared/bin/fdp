#!/usr/bin/env bash
#
# fdp: Find Projects - Discovers project directories based on configurable markers
#
# Usage:
#   fdp                    # List all projects
#   fdp | fzf              # Fuzzy find projects
#   cd $(fdp | fzf)        # cd to selected project
#
# Config: ~/.config/fdp/config.conf

set -euo pipefail

CONFIG_FILE="${XDG_CONFIG_HOME:-$HOME/.config}/fdp/config.conf"

# Cache configuration
CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/fdp"
CACHE_TTL=300  # 5 minutes default
USE_CACHE=true
VERBOSE=false
DEBUG_START_TIME=""

# Show help message
show_help() {
  cat <<EOF
fdp: Find Projects - Discovers project directories based on configurable markers

Usage:
  fdp [OPTIONS]
  fdp | fzf              # Fuzzy find projects
  cd \$(fdp | fzf)        # cd to selected project

Options:
  -c, --config FILE      Use custom config file (default: ~/.config/fdp/config.conf)
  -p, --path PATH        Add search path (can be repeated, merges with config)
  -m, --marker MARKER    Add project marker (can be repeated, merges with config)
  -e, --exclude PATTERN  Exclude pattern for fd (can be repeated, merges with config)
  -d, --max-depth NUM    Override maximum search depth (overrides config)
  --no-cache             Skip cache, force fresh search
  --clear-cache          Clear all fdp cache files and exit
  -v, --verbose          Enable debug output (shows timing and cache info)
  -h, --help             Show this help message

Examples:
  fdp                                    # Use config/defaults
  fdp --config ~/my-projects.conf        # Use custom config file
  fdp --max-depth 1                      # Shallow search
  fdp --path ~/experimental              # Add temporary search path
  fdp --marker "Dockerfile"              # Add custom marker
  fdp --exclude ".terraform" -e "vendor" # Exclude patterns
  fdp -p ~/temp -m "go.work" -d 2        # Combine multiple flags
  fdp --no-cache                         # Skip cache and search fresh
  fdp --clear-cache                      # Clear all cached results

Config file: ${CONFIG_FILE}
See: https://github.com/sharkdp/fd for exclude pattern syntax
EOF
}

# Default configuration
DEFAULT_SEARCH_PATHS=(
  "$HOME/projects"
  "$HOME/code"
  "$HOME/src"
)

DEFAULT_MARKERS=(
  ".git"
  "package.json"
  "Cargo.toml"
  "go.mod"
  "pyproject.toml"
  "composer.json"
  "Gemfile"
  "mix.exs"
  "pom.xml"
  "build.gradle"
  "Makefile"
)

DEFAULT_MAX_DEPTH=3
DEFAULT_EXCLUDES=()

# Arrays to hold config values
CONFIG_SEARCH_PATHS=()
CONFIG_MARKERS=()
CONFIG_MAX_DEPTH=""
CONFIG_EXCLUDES=()

# Arrays to hold CLI flag values
CLI_SEARCH_PATHS=()
CLI_MARKERS=()
CLI_MAX_DEPTH=""
CLI_EXCLUDES=()

# Parse command-line arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help)
      show_help
      exit 0
      ;;
    --clear-cache)
      rm -rf "${CACHE_DIR}" 2>/dev/null || true
      echo "Cache cleared: ${CACHE_DIR}" >&2
      exit 0
      ;;
    --no-cache)
      USE_CACHE=false
      shift
      ;;
    -v|--verbose)
      VERBOSE=true
      shift
      ;;
    -c|--config)
      if [[ -z "${2:-}" ]]; then
        echo "Error: --config requires a value" >&2
        exit 1
      fi
      # Expand tilde
      CONFIG_FILE="${2/#\~/$HOME}"
      shift 2
      ;;
    -p|--path)
      if [[ -z "${2:-}" ]]; then
        echo "Error: --path requires a value" >&2
        exit 1
      fi
      # Expand tilde and environment variables
      path="${2/#\~/$HOME}"
      path=$(eval echo "${path}")
      CLI_SEARCH_PATHS+=("${path}")
      shift 2
      ;;
    -m|--marker)
      if [[ -z "${2:-}" ]]; then
        echo "Error: --marker requires a value" >&2
        exit 1
      fi
      CLI_MARKERS+=("$2")
      shift 2
      ;;
    -e|--exclude)
      if [[ -z "${2:-}" ]]; then
        echo "Error: --exclude requires a value" >&2
        exit 1
      fi
      CLI_EXCLUDES+=("$2")
      shift 2
      ;;
    -d|--max-depth)
      if [[ -z "${2:-}" ]]; then
        echo "Error: --max-depth requires a value" >&2
        exit 1
      fi
      if ! [[ "$2" =~ ^[0-9]+$ ]]; then
        echo "Error: --max-depth must be a number" >&2
        exit 1
      fi
      CLI_MAX_DEPTH="$2"
      shift 2
      ;;
    *)
      echo "Error: Unknown option: $1" >&2
      echo "Run 'fdp --help' for usage information" >&2
      exit 1
      ;;
  esac
done

# Read config file if it exists
if [[ -f "${CONFIG_FILE}" ]]; then
  while IFS= read -r line || [[ -n "${line}" ]]; do
    # Skip empty lines and comments
    [[ -z "${line}" || "${line}" =~ ^[[:space:]]*# ]] && continue

    # Parse search_path entries
    if [[ "${line}" =~ ^search_path[[:space:]]*=[[:space:]]*(.+)$ ]]; then
      path="${BASH_REMATCH[1]}"
      # Expand tilde
      path="${path/#\~/$HOME}"
      CONFIG_SEARCH_PATHS+=("${path}")
    # Parse marker entries
    elif [[ "${line}" =~ ^marker[[:space:]]*=[[:space:]]*([^#[:space:]]+) ]]; then
      CONFIG_MARKERS+=("${BASH_REMATCH[1]}")
    # Parse exclude entries
    elif [[ "${line}" =~ ^exclude[[:space:]]*=[[:space:]]*(.+)$ ]]; then
      CONFIG_EXCLUDES+=("${BASH_REMATCH[1]}")
    # Parse max_depth
    elif [[ "${line}" =~ ^max_depth[[:space:]]*=[[:space:]]*([0-9]+) ]]; then
      CONFIG_MAX_DEPTH="${BASH_REMATCH[1]}"
    fi
  done < "${CONFIG_FILE}"
fi

# Merge configuration: CLI flags + Config + Defaults
# Multi-value options (search_path, marker, exclude): Additive merge
# Single-value options (max_depth): CLI > Config > Default

# Merge search paths: config + CLI (or defaults if both empty)
SEARCH_PATHS=("${CONFIG_SEARCH_PATHS[@]}" "${CLI_SEARCH_PATHS[@]}")
[[ ${#SEARCH_PATHS[@]} -eq 0 ]] && SEARCH_PATHS=("${DEFAULT_SEARCH_PATHS[@]}")

# Merge markers: config + CLI (or defaults if both empty)
MARKERS=("${CONFIG_MARKERS[@]}" "${CLI_MARKERS[@]}")
[[ ${#MARKERS[@]} -eq 0 ]] && MARKERS=("${DEFAULT_MARKERS[@]}")

# Merge excludes: config + CLI (or defaults if both empty)
EXCLUDES=("${CONFIG_EXCLUDES[@]}" "${CLI_EXCLUDES[@]}")
[[ ${#EXCLUDES[@]} -eq 0 ]] && EXCLUDES=("${DEFAULT_EXCLUDES[@]}")

# Max depth: CLI overrides config, fallback to default
MAX_DEPTH="${CLI_MAX_DEPTH:-${CONFIG_MAX_DEPTH:-$DEFAULT_MAX_DEPTH}}"

# Filter search paths that actually exist
EXISTING_PATHS=()
for path in "${SEARCH_PATHS[@]}"; do
  [[ -d "${path}" ]] && EXISTING_PATHS+=("${path}")
done

# Exit if no valid search paths
if [[ ${#EXISTING_PATHS[@]} -eq 0 ]]; then
  echo "Error: No valid search paths found" >&2
  exit 1
fi

# Check if fd is available
if ! command -v fd &> /dev/null; then
  echo "Error: 'fd' command not found. Please install fd-find." >&2
  echo "  macOS: brew install fd" >&2
  echo "  Ubuntu: apt install fd-find" >&2
  exit 1
fi

# Build fd regex pattern from markers
# Escape special regex characters and join with |
build_pattern() {
  local pattern=""
  for marker in "${MARKERS[@]}"; do
    # Escape dots and other regex special chars
    local escaped="${marker//./\\.}"
    escaped="${escaped//\$/\\$}"

    # Add anchors for exact match
    if [[ "${marker}" == .* ]]; then
      # Hidden files/dirs like .git
      pattern="${pattern}^${escaped}\$|"
    else
      # Regular files like package.json
      pattern="${pattern}^${escaped}\$|"
    fi
  done
  # Remove trailing |
  echo "${pattern%|}"
}

PATTERN=$(build_pattern)

# Build exclude arguments for fd
EXCLUDE_ARGS=()
for exclude in "${EXCLUDES[@]}"; do
  EXCLUDE_ARGS+=(--exclude "${exclude}")
done

# Debug output
if [[ "${VERBOSE}" == "true" ]]; then
  echo "DEBUG: PATTERN: ${PATTERN}" >&2
  echo "DEBUG: MAX_DEPTH: ${MAX_DEPTH}" >&2
  echo "DEBUG: PATHS: ${EXISTING_PATHS[@]}" >&2
  echo "DEBUG: EXCLUDES: ${EXCLUDES[@]}" >&2
  echo "DEBUG: CACHE_DIR: ${CACHE_DIR}" >&2
  DEBUG_START_TIME=$(date +%s%3N)
fi

# Generate cache file key based on search parameters
# Use hash of all config to detect changes
get_cache_file() {
  local cache_key
  cache_key=$(echo "${SEARCH_PATHS[@]}:${MARKERS[@]}:${EXCLUDES[@]}:${MAX_DEPTH}" | md5sum | cut -d' ' -f1)
  echo "${CACHE_DIR}/cache-${cache_key}.txt"
}

CACHE_FILE=$(get_cache_file)

# Check cache validity and return early if valid
check_and_use_cache() {
  if [[ "${USE_CACHE}" != "true" || ! -f "${CACHE_FILE}" ]]; then
    return 1
  fi

  # Check cache age
  if command -v stat &> /dev/null; then
    # Try macOS stat format first, fall back to Linux
    local cache_age
    if stat -f %m "${CACHE_FILE}" &>/dev/null; then
      cache_age=$(($(date +%s) - $(stat -f %m "${CACHE_FILE}")))
    else
      cache_age=$(($(date +%s) - $(stat -c %Y "${CACHE_FILE}")))
    fi

    if [[ ${cache_age} -lt ${CACHE_TTL} ]]; then
      cat "${CACHE_FILE}"
      if [[ "${VERBOSE}" == "true" ]]; then
        echo "DEBUG: Cache hit (age: ${cache_age}s)" >&2
      fi
      return 0
    fi
  fi

  return 1
}

# Try to use cache
if check_and_use_cache; then
  if [[ "${VERBOSE}" == "true" ]]; then
    echo "DEBUG: Using cached results" >&2
  fi
  exit 0
fi

if [[ "${VERBOSE}" == "true" ]]; then
  echo "DEBUG: Cache miss or disabled, searching..." >&2
fi

# Optimized search using --exec-batch for efficient directory extraction
# Original: --exec dirname {} \;  (spawns one dirname per file)
# Optimized: --exec-batch dirname (batches multiple paths per dirname call)
# This reduces process spawning from ~1500 to ~15-50 calls for large codebases

results=$(
  fd --hidden \
     --no-ignore-vcs \
     --max-depth "${MAX_DEPTH}" \
     --regex "${PATTERN}" \
     "${EXCLUDE_ARGS[@]}" \
     "${EXISTING_PATHS[@]}" \
     --exec-batch dirname \
  | sort -u
)

# Write results to cache and output
mkdir -p "${CACHE_DIR}"
echo "${results}" | tee "${CACHE_FILE}"

if [[ "${VERBOSE}" == "true" ]]; then
  local debug_end_time=$(date +%s%3N)
  local elapsed=$((debug_end_time - DEBUG_START_TIME))
  local line_count=$(echo "${results}" | wc -l)
  echo "DEBUG: Search completed in ${elapsed}ms" >&2
  echo "DEBUG: Found ${line_count} projects" >&2
fi
